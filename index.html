<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bomb Diffusal — Pyramid (Cascade + Hazard Lock, Lite)</title>
<style>
  :root{
    --bg:#0b0f19; --panel:#121826; --ink:#e8edff; --muted:#a8b6e8;
    --accent:#69a7ff; --line:#1b2544; --chip:#0f1730; --danger:#ff6b6b; --ok:#18c964;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0f1630,#0b0f19)}
  h1{margin:0 0 6px;font-size:18px;letter-spacing:.2px}
  .bar{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:13px}
  main{display:grid;grid-template-columns:1fr 340px;gap:12px;padding:12px}
  @media (max-width: 960px){ main{grid-template-columns:1fr} aside{order:-1} }
  .zone{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls .row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  button{background:#0f1730;color:var(--ink);border:1px solid #2a3a69;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  button.primary{background:var(--accent);border:none;color:#001b3a}
  button:disabled{opacity:.45;cursor:not-allowed}
  select{background:#0f1730;border:1px solid #2a3a69;color:var(--ink);border-radius:8px;padding:6px}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chip{background:#0f1730;border:1px solid #24356a;border-radius:999px;padding:2px 8px;font-size:12px;color:#cbd7ff}
  .grid{display:grid;gap:12px}
  .p1Row{display:grid;grid-template-columns:1fr;gap:12px}
  .botsRow{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width: 1100px){ .botsRow{grid-template-columns:1fr} }
  .player{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .player h2{margin:0 0 8px;font-size:14px;color:var(--muted)}
  .me{outline:2px solid rgba(105,167,255,.35)}
  .note{font-size:12px;color:var(--muted);margin-top:6px}
  .hand{display:flex;gap:6px;flex-wrap:wrap}
  .pyramid{display:grid;gap:6px}
  .py-row{display:flex;gap:6px;justify-content:center}
  .slot{width:42px;height:58px;border:1px dashed #31406f;border-radius:8px;display:flex;align-items:center;justify-content:center}
  .exposed{outline:2px solid rgba(105,167,255,.6)}
  .card{
    display:inline-flex;align-items:center;justify-content:center;
    min-width:44px;height:58px;border-radius:8px;border:1px solid #31406f;
    background:linear-gradient(180deg,#101a36,#0c1226);font-weight:700;user-select:none;padding:0 6px
  }
  .mini{min-width:36px;height:46px;font-size:13px}
  .card.s-C{color:#8ae66e} .card.s-H{color:#ff9bb3}
  .card.s-D{color:#7fd1ff} .card.s-S{color:#d0c6ff}
  .card.A{border-color:#ffd86b;box-shadow:inset 0 0 0 1px #ffd86b}
  .card.face{border-color:#ff9f6b}
  .card.hazard{background:linear-gradient(180deg,#2a0f14,#19080b);border-color:#7a2a37}
  .dim{opacity:.5;filter:grayscale(.7)}
  .clickable{cursor:pointer}
  .selected{outline:2px solid var(--accent)}
  aside .zone{position:sticky;top:12px}
  #lastPlay{font-size:13px;line-height:1.35}
  #hint{min-height:18px;color:var(--muted);margin-top:6px}
  /* small visual pop for cascades */
  .pop{animation:pop .5s ease}
  @keyframes pop{0%{transform:scale(.95)}70%{transform:scale(1.03)}100%{transform:scale(1)}}
</style>
</head>
<body>
<header>
  <h1>Bomb Diffusal — Pyramid (Cascade + Hazard Lock, Lite)</h1>
  <div class="bar">
    <span id="turnSpan"></span>
    <span id="deckSpan"></span>
    <span id="reshuffleSpan"></span>
    <span id="coreSpan"></span>
    <span id="targetsSpan"></span>
  </div>
</header>

<main>
  <section class="grid">
    <div class="zone controls">
      <div class="row">
        <button id="newBtn" class="primary">New Game</button>
        <label>Speed:
          <select id="speedSel">
            <option value="700">Normal</option>
            <option value="350" selected>Fast</option>
            <option value="140">Turbo</option>
          </select>
        </label>
        <label><input id="autoP1" type="checkbox" /> Auto-play Player 1</label>
      </div>
      <div class="row">
        <button id="playBtn" disabled>Play Selected (Attempt)</button>
        <button id="skipBtn" disabled>Skip</button>
      </div>
      <div class="chips">
        <span class="chip">Cascade: <strong>up to 3 clears</strong></span>
        <span class="chip">Hazards: <strong>face-up + lock</strong></span>
        <span class="chip">Loss: <strong>Deck exhausted (1 reshuffle)</strong></span>
      </div>
      <div id="hint">You’re Player 1. Select a card, then “Play Selected”. Bots auto-help if needed.</div>
    </div>

    <!-- Player 1 always visible -->
    <div class="p1Row"><div class="player me" id="p0Box"></div></div>
    <!-- Three bot seats -->
    <div class="botsRow">
      <div class="player" id="p1Box"></div>
      <div class="player" id="p2Box"></div>
      <div class="player" id="p3Box"></div>
    </div>
  </section>

  <aside>
    <div class="zone">
      <h3 style="margin:0 0 8px">Last play</h3>
      <div id="lastPlay">—</div>
    </div>
  </aside>
</main>

<script>
/* ======= Minimal-state helpers ======= */
let ended = false;
const GL={C:"♣",D:"♦",H:"♥",S:"♠"};
const SUITS=["C","D","H","S"];
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RVAL=r=>r==="A"?1:r==="J"?11:r==="Q"?12:r==="K"?13:+r;
const isFace=r=>r==="J"||r==="Q"||r==="K";
const label=c=>c?((c.r==="Joker")?"Joker★":(c.r+GL[c.s])):"—";
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function makeDeck(){
  const d=[]; for(const s of SUITS)for(const r of RANKS)d.push({s,r});
  d.push({r:"Joker",s:"★"}); d.push({r:"Joker",s:"★"}); // two jokers
  return shuffle(d);
}

/* ======= Core state ======= */
const S={
  deck:[], discard:[],
  players:[], // {seat,name,isHuman,hand:[],pyr:{rows}}
  turn:0, speed:350, autoP1:false,
  reshufflesLeft:1, started:false,
  core:{card:null, exposed:false, cleared:false},
  lastPlay:"—", // compact memory
};
function newPlayer(i,isHuman){return{seat:i,name:isHuman?"You":"Bot "+(i+1),isHuman,hand:[],pyr:null}}

/* ======= Pyramid build (bottom row face-up; hazards lock) ======= */
function buildPyramid(D){
  const rows=[[],[],[]];
  for(let i=0;i<3;i++) rows[0].push({card:D.pop(),hidden:false,hazard:false});
  for(let i=0;i<2;i++) rows[1].push({card:D.pop(),hidden:true,hazard:false});
  rows[2].push({card:D.pop(),hidden:true,hazard:false});
  return {rows};
}
function exposedSlots(p){
  const R=p.pyr.rows, out=[];
  // bottom row: any present and not hidden
  for(let c=0;c<3;c++) if(R[0][c] && !R[0][c].hidden) out.push({row:0,col:c});
  // middle row: only if both supports are empty (hazards count as not empty → lock)
  for(let c=0;c<2;c++){
    if(R[1][c] && !R[1][c].hidden && !R[0][c] && !R[0][c+1]) out.push({row:1,col:c});
  }
  // top: only if middle both empty
  if(R[2][0] && !R[2][0].hidden && !R[1][0] && !R[1][1]) out.push({row:2,col:0});
  return out;
}
function flipExposures(p){
  const R=p.pyr.rows;
  // Reveal middle only if bottoms are empty (hazard lock enforced because hazards occupy the bottom cells)
  for(let c=0;c<2;c++){
    if(R[1][c] && R[1][c].hidden && !R[0][c] && !R[0][c+1]) R[1][c].hidden=false;
  }
  // Reveal top only if middle empty
  if(R[2][0] && R[2][0].hidden && !R[1][0] && !R[1][1]) R[2][0].hidden=false;
}

/* ======= Deal & flow ======= */
function startGame(){
  ended=false; S.started=true; S.reshufflesLeft=1; S.lastPlay="—";
  S.deck=makeDeck(); S.discard.length=0;
  S.players=[newPlayer(0,true),newPlayer(1,false),newPlayer(2,false),newPlayer(3,false)];
  for(const p of S.players){ p.pyr=buildPyramid(S.deck); }
  // shared core
  S.core.card=S.deck.pop(); S.core.exposed=false; S.core.cleared=false;
  // hands (5)
  for(const p of S.players){ for(let i=0;i<5;i++) drawOne(p.seat); }
  S.turn=0;
  renderAll();
  if(!S.players[0].isHuman || S.autoP1) runTurn();
}
function reshuffleIfNeeded(){
  if(S.deck.length===0 && S.reshufflesLeft>0 && S.discard.length){
    S.deck=shuffle(S.discard); S.discard=[]; S.reshufflesLeft--;
  }
}
function drawOne(seat){
  if(S.deck.length===0){ reshuffleIfNeeded(); }
  if(S.deck.length===0){ endGame(false,"Deck exhausted."); return false; }
  S.players[seat].hand.push(S.deck.pop()); return true;
}
function drawUpTo5IfEmpty(seat){
  const P=S.players[seat];
  if(P.hand.length===0){
    for(let i=0;i<5;i++){ if(!drawOne(seat)) return false; }
  }
  return true;
}

/* ======= Math rules ======= */
function isJoker(c){ return c && c.r==="Joker"; }
function isNumeric(c){ return c && !isJoker(c) && !isFace(c.r); }
function isMatch(base,h1,h2,targetVal){
  // Jokers auto-win
  if(isJoker(base) || isJoker(h1) || isJoker(h2)) return true;
  if(targetVal==null) return true; // Joker target
  if(isFace(base.r)) return false;
  const b=RVAL(base.r);
  const equalsTarget = v => v===targetVal;

  // 0 helper
  if(!h1 && !h2) return equalsTarget(b);

  // 1 helper
  if(h1 && !h2){
    if(isNumeric(h1)){
      const a=RVAL(h1.r);
      return equalsTarget(b+a) || equalsTarget(b-a);
    }else{
      // face helper doesn't contribute numeric; without Joker it's no help
      return false;
    }
  }

  // 2 helpers
  if(h1 && h2){
    if(isNumeric(h1) && isNumeric(h2)){
      const a=RVAL(h1.r), c2=RVAL(h2.r);
      return [b+a+c2,b+a-c2,b-a+c2,b-a-c2].some(equalsTarget);
    }else{
      return false;
    }
  }
  return false;
}

/* ======= Bot logic (first solvable: 0→1→2 helpers; core first) ======= */
function seatLeftRight(seat){ return [(seat+3)%4,(seat+1)%4]; }

function chooseBotPlay(seat){
  const P=S.players[seat]; const [L,R]=seatLeftRight(seat);

  const trySolve=(base,targetVal)=>{
    // 0 helpers
    if(isMatch(base,null,null,targetVal)) return {helpers:[]};
    // 1 helper (L then R)
    for(const hs of [L,R]){
      for(let i=0;i<S.players[hs].hand.length;i++){
        const h1=S.players[hs].hand[i];
        if(isMatch(base,h1,null,targetVal)) return {helpers:[{hs,idx:i}]};
      }
    }
    // 2 helpers (L/R combos)
    for(const hs1 of [L,R]){
      for(const hs2 of [L,R]){
        if(hs2===hs1) continue;
        for(let i=0;i<S.players[hs1].hand.length;i++){
          for(let j=0;j<S.players[hs2].hand.length;j++){
            const h1=S.players[hs1].hand[i], h2=S.players[hs2].hand[j];
            if(isMatch(base,h1,h2,targetVal)) return {helpers:[{hs:hs1,idx:i},{hs:hs2,idx:j}]};
          }
        }
      }
    }
    return null;
  };

  const targetList=[];
  if(S.core.exposed && S.core.card){
    targetList.push({where:"core", pos:null, val:isJoker(S.core.card)?null:RVAL(S.core.card.r)});
  }
  const xs=exposedSlots(P);
  for(const pos of xs){
    const tc=P.pyr.rows[pos.row][pos.col].card;
    targetList.push({where:"pyr", pos, val:isJoker(tc)?null:RVAL(tc.r)});
  }

  for(let bi=0; bi<P.hand.length; bi++){
    const base=P.hand[bi];
    for(const t of targetList){
      const sol=trySolve(base, t.val);
      if(sol){ return {bi, where:t.where, pos:t.pos, helpers:sol.helpers}; }
    }
  }
  // no solvable → dump first
  if(P.hand.length) return {bi:0, where:null, pos:null, helpers:[]};
  return null;
}

/* ======= Attempt + Cascade Clear ======= */
function applyAttempt(plan){
  const P=S.players[S.turn];
  const base=P.hand.splice(plan.bi,1)[0]; S.discard.push(base);

  // Take helpers and discard them now (we will still "reuse" their values for cascade math)
  const helpers=[];
  const bySeat=new Map();
  for(const h of plan.helpers){
    const c=S.players[h.hs].hand[h.idx];
    helpers.push({hs:h.hs, idx:h.idx, card:c});
    if(!bySeat.has(h.hs)) bySeat.set(h.hs,[]);
    bySeat.get(h.hs).push(h.idx);
  }
  for(const [hs,arr] of bySeat){ arr.sort((a,b)=>b-a).forEach(i=>S.discard.push(S.players[hs].hand.splice(i,1)[0])); }

  let success=false, clearedCount=0, firstTargetLabel="—", finalTargetLabel="—";
  const baseCard=base, h1=helpers[0]?.card||null, h2=helpers[1]?.card||null;

  // helper to clear a particular target cell (already confirmed match)
  const clearTargetCell=(pos)=>{
    const cell=P.pyr.rows[pos.row][pos.col];
    const tcard=cell.card;
    P.pyr.rows[pos.row][pos.col]=null;
    flipExposures(P);
    if(!P.pyr.rows[2][0]) S.core.exposed=true;
    return tcard;
  };

  // Main resolution:
  if(plan.where==="core"){
    // Core clear (cascade doesn't apply past core)
    success=true; clearedCount=1; firstTargetLabel="CORE "+label(S.core.card); finalTargetLabel=firstTargetLabel;
    S.core.cleared=true;
  }else if(plan.where==="pyr"){
    const cell=P.pyr.rows[plan.pos.row][plan.pos.col];
    const tcard=cell.card;
    const tval = isJoker(tcard)? null : RVAL(tcard.r);
    if(isMatch(baseCard, h1, h2, tval)){
      success=true;
      clearTargetCell(plan.pos);
      clearedCount=1;
      firstTargetLabel=label(tcard);
      finalTargetLabel=firstTargetLabel;

      // CASCADE: try up to 2 more clears with the SAME combo
      for(let extra=0; extra<2; extra++){
        // Check core first if it just exposed
        if(S.core.exposed && !S.core.cleared && S.core.card){
          const coreVal = isJoker(S.core.card)? null : RVAL(S.core.card.r);
          if(isMatch(baseCard, h1, h2, coreVal)){
            S.core.cleared=true;
            clearedCount++;
            finalTargetLabel="CORE "+label(S.core.card);
            break; // end cascade on core clear (win condition)
          }
        }
        // Else check any new exposed on this player's pyramid
        const xs=exposedSlots(P);
        let cascaded=false;
        for(const pos of xs){
          const c2=P.pyr.rows[pos.row][pos.col].card;
          const v2=isJoker(c2)?null:RVAL(c2.r);
          if(isMatch(baseCard, h1, h2, v2)){
            const cleared=clearTargetCell(pos);
            clearedCount++;
            finalTargetLabel=label(cleared);
            cascaded=true;
            break; // one at a time
          }
        }
        if(!cascaded) break; // stop cascade if no further match
      }
    }
  }else{
    // dump (no target)
  }

  // Aftermath: success/fail flow (with face-up hazard and lock already enforced via exposure logic)
  if(success){
    // Active refills: draw 1 (cascade doesn’t alter refill)
    if(!drawOne(P.seat)){ return; }
  }else{
    // Fail → place face-up hazard on active pyramid + draw 1
    addHazardToActive();
    if(!drawOne(P.seat)){ return; }
  }

  // zero-hand refill rule for anyone who hit 0
  for(const pl of S.players){ if(pl.hand.length===0){ for(let i=0;i<5;i++) if(!drawOne(pl.seat)) break; } }

  // Last play summary
  const helperStr = helpers.map(h=>label(h.card)).join(", ") || "—";
  const tgtStr = plan.where==="core" ? ("CORE "+label(S.core.card)) :
                 plan.where==="pyr"  ? firstTargetLabel :
                 "—";
  const cas = success ? (clearedCount>1 ? ` + Cascade x${clearedCount-1}` : "") : "";
  S.lastPlay = `${P.name} | Base ${label(baseCard)} | Helpers ${helperStr} | Target ${tgtStr} | ${success?"✅ Success":"❌ Fail"}${cas}`;

  // Win/lose?
  if(S.core.cleared){ endGame(true,"Core defused! Team wins."); return; }

  // Continue
  S.turn=(S.turn+1)%4;
  renderAll();
  runTurn();
}

function addHazardToActive(){
  const P=S.players[S.turn];
  const order=[[0,0],[0,1],[0,2],[1,0],[1,1],[2,0]];
  if(S.deck.length===0){ reshuffleIfNeeded(); }
  if(S.deck.length===0){ endGame(false,"Deck exhausted."); return; }
  const card=S.deck.pop();
  for(const [r,c] of order){
    if(!P.pyr.rows[r][c]){
      // Face-up hazard (locks above by occupying the slot)
      P.pyr.rows[r][c]={card,hidden:false,hazard:true};
      break;
    }
  }
}

/* ======= Human controls ======= */
let selectedHandIdx=null;
function canHumanAct(){ return S.started && !ended && S.turn===0 && !S.autoP1; }

function playSelected(){
  if(!canHumanAct() || selectedHandIdx==null) return;
  const P=S.players[0];
  const baseIdx=selectedHandIdx;
  const [L,R]=seatLeftRight(0);
  const trySolve=(targetVal)=>{
    if(isMatch(P.hand[baseIdx],null,null,targetVal)) return {helpers:[]};
    for(const hs of [L,R]){
      for(let i=0;i<S.players[hs].hand.length;i++){
        if(isMatch(P.hand[baseIdx], S.players[hs].hand[i], null, targetVal)) return {helpers:[{hs,idx:i}]};
      }
    }
    for(const hs1 of [L,R]) for(const hs2 of [L,R]){
      if(hs2===hs1) continue;
      for(let i=0;i<S.players[hs1].hand.length;i++)
        for(let j=0;j<S.players[hs2].hand.length;j++)
          if(isMatch(P.hand[baseIdx], S.players[hs1].hand[i], S.players[hs2].hand[j], targetVal))
            return {helpers:[{hs:hs1,idx:i},{hs:hs2,idx:j}]};
    }
    return null;
  };

  const targets=[];
  if(S.core.exposed && S.core.card) targets.push({where:"core",val:isJoker(S.core.card)?null:RVAL(S.core.card.r)});
  const xs=exposedSlots(P);
  for(const pos of xs){ const c=P.pyr.rows[pos.row][pos.col].card; targets.push({where:"pyr",pos,val:isJoker(c)?null:RVAL(c.r)}); }

  for(const t of targets){
    const sol = trySolve(t.val);
    if(sol){ const plan={bi:baseIdx, where:t.where, pos:t.pos||null, helpers:sol.helpers}; selectedHandIdx=null; return applyAttempt(plan); }
  }
  // none → dump
  const plan={bi:baseIdx, where:null, pos:null, helpers:[]}; selectedHandIdx=null; applyAttempt(plan);
}

function skipHuman(){
  if(!canHumanAct()) return;
  if(S.players[0].hand.length===0) return;
  const plan={bi:0, where:null, pos:null, helpers:[]};
  applyAttempt(plan);
}

/* ======= Bot flow ======= */
function runTurn(){
  if(ended || !S.started) return;
  updateBars();
  if(S.turn===0 && !S.autoP1){ renderAll(); return; }
  const plan=chooseBotPlay(S.turn) || {bi:0,where:null,pos:null,helpers:[]};
  setTimeout(()=>applyAttempt(plan), S.speed);
}

/* ======= Render ======= */
function cardEl(c, cls=""){
  const d=document.createElement("div"); d.className="card "+cls+(c.s?` s-${c.s}`:"");
  if(c.hazard) d.classList.add("hazard");
  d.textContent=(c.r==="Joker")?"J★":(c.r+GL[c.s]);
  if(c.r==="A") d.classList.add("A");
  if(isFace(c.r)) d.classList.add("face");
  return d;
}
function hiddenEl(){const d=document.createElement("div"); d.className="card dim"; d.textContent="🂠"; return d;}
function emptySlot(){const d=document.createElement("div"); d.className="slot"; return d;}

function renderPyramid(p){
  const wrap=document.createElement("div"); wrap.className="pyramid";
  const R=p.pyr.rows;
  const r2=document.createElement("div"); r2.className="py-row";
  r2.appendChild(R[2][0]? (R[2][0].hidden? hiddenEl() : cardEl(R[2][0].card,"")) : emptySlot()); wrap.appendChild(r2);
  const r1=document.createElement("div"); r1.className="py-row";
  for(let i=0;i<2;i++) r1.appendChild(R[1][i]? (R[1][i].hidden? hiddenEl() : cardEl(R[1][i].card,"")) : emptySlot()); wrap.appendChild(r1);
  const r0=document.createElement("div"); r0.className="py-row";
  for(let i=0;i<3;i++) r0.appendChild(R[0][i]? (R[0][i].hidden? hiddenEl() : cardEl(R[0][i].card,"")) : emptySlot()); wrap.appendChild(r0);
  // exposed highlights
  for(const ex of exposedSlots(p)){ const rows=wrap.querySelectorAll(".py-row"); const idx=(ex.row===2)?0:(ex.row===1?1:2); rows[idx].children[ex.col].classList.add("exposed"); rows[idx].children[ex.col].classList.add("pop"); }
  return wrap;
}
function chip(t){const s=document.createElement("span"); s.className="chip"; s.textContent=t; return s;}
function renderPlayer(p, el, showHand){
  el.innerHTML="";
  const h2=document.createElement("h2"); h2.textContent=p.name+(S.turn===p.seat?" — Turn":""); el.appendChild(h2);
  const chips=document.createElement("div"); chips.className="chips";
  chips.appendChild(chip(`Hand: ${p.hand.length}`));
  el.appendChild(chips);
  el.appendChild(renderPyramid(p));
  const lab=document.createElement("div"); lab.className="note"; lab.textContent=showHand?"Your hand (select one):":"Hand (hidden)"; el.appendChild(lab);
  const hand=document.createElement("div"); hand.className="hand";
  if(showHand){
    p.hand.forEach((c,i)=>{const n=cardEl(c,"clickable"); if(selectedHandIdx===i) n.classList.add("selected"); n.onclick=()=>{selectedHandIdx=i; renderAll();}; hand.appendChild(n);});
  }else{
    p.hand.forEach(()=>hand.appendChild(hiddenEl()));
  }
  el.appendChild(hand);
}
function updateBars(){
  document.getElementById("turnSpan").textContent=S.started?`Turn: ${S.players[S.turn].name}`:"";
  document.getElementById("deckSpan").textContent=S.started?`Deck: ${S.deck.length}`:"";
  document.getElementById("reshuffleSpan").textContent=S.started?`Reshuffles: ${S.reshufflesLeft}`:"";
  document.getElementById("coreSpan").textContent=S.started?`Core: ${S.core.exposed?(S.core.cleared?"CLEARED":label(S.core.card)):"—"}`:"";
  document.getElementById("targetsSpan").textContent=S.started?`Your targets: ${S.turn===0?targetRanksForActive().join(", "):"—"}`:"";
  document.getElementById("lastPlay").textContent=S.lastPlay || "—";
}
function targetRanksForActive(){
  const P=S.players[S.turn];
  const slots=exposedSlots(P).map(pos=>P.pyr.rows[pos.row][pos.col].card);
  const coreOK = S.core.exposed && S.core.card;
  const ranks = slots.map(c=>c.r);
  if(coreOK){ ranks.push(S.core.card.r); }
  return ranks;
}
function renderAll(){
  updateBars();
  if(!S.started) return;
  renderPlayer(S.players[0], document.getElementById("p0Box"), !S.autoP1);
  renderPlayer(S.players[1], document.getElementById("p1Box"), false);
  renderPlayer(S.players[2], document.getElementById("p2Box"), false);
  renderPlayer(S.players[3], document.getElementById("p3Box"), false);
  document.getElementById("playBtn").disabled=!(canHumanAct() && selectedHandIdx!=null);
  document.getElementById("skipBtn").disabled=!canHumanAct();
}

/* ======= End game ======= */
function endGame(win,msg){
  if(ended) return; ended=true; S.started=false;
  document.getElementById("hint").textContent=(win?"🏆 ":"💥 ")+msg+"  Click New Game to restart.";
  renderAll();
}

/* ======= Wire up ======= */
document.getElementById("newBtn").onclick=()=>{ selectedHandIdx=null; startGame(); };
document.getElementById("speedSel").onchange=e=>{ S.speed=+e.target.value; };
document.getElementById("autoP1").onchange=e=>{ S.autoP1=e.target.checked; renderAll(); if(S.autoP1 && S.turn===0) runTurn(); };
document.getElementById("playBtn").onclick=playSelected;
document.getElementById("skipBtn").onclick=skipHuman;

/* Boot */
renderAll();
</script>
</body>
</html>
