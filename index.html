<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bomb Diffusal ‚Äì Core-Lite</title>
<style>
  :root{
    --bg:#0b0f19; --panel:#121826; --ink:#e6ebff; --muted:#9fb1ff;
    --accent:#5aa9ff; --danger:#ff6b6b; --ok:#17c964; --chip:#1b2340;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid #1c2542;background:linear-gradient(180deg,#0d1424,#0b0f19)}
  h1{margin:0 0 6px;font-size:20px}
  #bar{font-size:13px;color:var(--muted);display:flex;gap:12px;flex-wrap:wrap}
  main{display:grid;grid-template-columns:1fr 340px;gap:16px;padding:16px}
  @media (max-width: 980px){ main{grid-template-columns:1fr} aside{order:-1} }
  .zone{background:var(--panel);border:1px solid #1c2542;border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--chip);border:1px solid #28345d;color:var(--ink);padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer}
  button.primary{background:var(--accent);border:none;color:#001332}
  button:disabled{opacity:.5;cursor:not-allowed}
  select{background:#0d1424;border:1px solid #28345d;color:var(--ink);border-radius:8px;padding:6px}
  .players{display:grid;gap:12px}
  .player{background:var(--panel);border:1px solid #1c2542;border-radius:12px;padding:12px}
  .player h2{margin:0 0 6px;font-size:15px;color:var(--muted)}
  .pyramid{display:grid;gap:6px}
  .py-row{display:flex;gap:6px;justify-content:center}
  .slot{width:44px;height:60px;border:1px dashed #31406f;border-radius:8px;display:flex;align-items:center;justify-content:center}
  .card{
    display:flex;align-items:center;justify-content:center;
    min-width:42px;height:60px;border-radius:8px;border:1px solid #31406f;
    background:linear-gradient(180deg,#0f1830,#0d1424);font-weight:700
  }
  .card.dim{opacity:.45}
  .exposed{outline:2px solid rgba(90,169,255,.5)}
  .haz{background:#2b0f12;border-color:#6a2330}
  .core{outline:2px dashed #ffd86b}
  .hand,.staging{display:flex;gap:6px;flex-wrap:wrap}
  .clickable{cursor:pointer}
  .tag{background:#162043;border:1px solid #2b3e7d;color:#c0d3ff;font-size:11px;padding:2px 6px;border-radius:999px}
  .tags{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0}
  #log{font-size:12px;line-height:1.35;max-height:50vh;overflow:auto;background:#0e1322;border:1px solid #1c2542;border-radius:8px;padding:8px}
  .pill{background:#0f1730;border:1px solid #24356a;padding:4px 8px;border-radius:999px}
</style>
</head>
<body>
<header>
  <h1>Bomb Diffusal ‚Äì Core-Lite</h1>
  <div id="bar">
    <span id="turnSpan"></span>
    <span id="deckSpan"></span>
    <span id="reshuffleSpan"></span>
    <span id="attemptSpan"></span>
  </div>
</header>

<main>
  <section class="table">
    <div class="zone">
      <div class="row">
        <button id="newBtn" class="primary">New Game</button>
        <label>Players
          <select id="playerCount">
            <option value="2">2 (you + 1 bot)</option>
            <option value="3" selected>3 (you + 2 bots)</option>
            <option value="4">4 (you + 3 bots)</option>
          </select>
        </label>
        <label>Your seat
          <select id="humanSeat">
            <option value="0" selected>P1</option><option value="1">P2</option>
            <option value="2">P3</option><option value="3">P4</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button id="playHand" disabled>Play Selected</button>
        <button id="useStage" disabled>Use Staging</button>
        <button id="stageCard" disabled>Stage Selected</button>
        <button id="useWild" disabled>Use Wild</button>
        <button id="skip" disabled>Skip</button>
      </div>
      <div class="row">
        <span class="pill">Attempt: <b id="attemptCount">0/3</b></span>
        <span class="pill">Targets: <b id="targets">‚Äì</b></span>
      </div>
    </div>

    <div id="players" class="players"></div>
  </section>

  <aside>
    <div class="zone">
      <h3 style="margin-top:0">Log</h3>
      <div id="log"></div>
    </div>
  </aside>
</main>

<script>
/* ===== Core-Lite State & Helpers ===== */
const SUITS=["C","D","H","S"], GLYPH={C:"‚ô£",D:"‚ô¶",H:"‚ô•",S:"‚ô†"};
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const isFace=r=>r==="J"||r==="Q"||r==="K";

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a;}
function makeDeck(){ const d=[]; for(const s of SUITS){ for(const r of RANKS){ d.push({s,r}); } } return shuffle(d); }
function label(c){ return c? c.r+GLYPH[c.s] : "‚Äî"; }

const S={
  players:[], seatCount:3, humanSeat:0,
  deck:[], discard:[], reshuffles:1,
  turn:0, attempt:[], contributed:new Set(), started:false, over:false
};

function newPlayer(i,isHuman){
  return{ seat:i, name:isHuman?"You":`Bot ${i+1}`, isHuman,
    hand:[], stage:null, wilds:0,
    pyramid:{ rows:[[],[],[]], core:{card:null,hidden:true} }
  };
}
function safeDraw(){
  if(S.deck.length===0){
    if(S.reshuffles>0){
      log("üîÑ Reshuffle.");
      S.deck = shuffle(S.discard); S.discard=[]; S.reshuffles--;
    } else { end(false,"Deck exhausted again. Boom!"); return null; }
  }
  return S.deck.pop();
}
function dealPyramid(P){
  for(let i=0;i<3;i++){ P.pyramid.rows[0].push({card:safeDraw(), hidden:false, haz:false}); }
  for(let i=0;i<2;i++){ P.pyramid.rows[1].push({card:safeDraw(), hidden:true, haz:false}); }
  P.pyramid.rows[2].push({card:safeDraw(), hidden:true, haz:false});
  P.pyramid.core={card:safeDraw(), hidden:true, haz:false, core:true};
}
function exposedSlots(P){
  const out=[], R=P.pyramid.rows;
  for(let c=0;c<3;c++){ if(R[0][c]) out.push({row:0,col:c,cell:R[0][c]}); }
  for(let c=0;c<2;c++){ if(R[1][c] && !R[0][c] && !R[0][c+1]) out.push({row:1,col:c,cell:R[1][c]}); }
  if(R[1].every(x=>!x) && R[2][0]) out.push({row:2,col:0,cell:R[2][0]});
  if(!R[2][0] && P.pyramid.core) out.push({row:3,col:0,cell:P.pyramid.core});
  return out.filter(x=>x.cell);
}
function flipAfterClear(P,row){
  const R=P.pyramid.rows;
  if(row===0){
    for(let c=0;c<2;c++){ if(!R[0][c] && !R[0][c+1] && R[1][c]?.hidden){ R[1][c].hidden=false; } }
    if(R[1].every(x=>!x) && R[2][0]?.hidden){ R[2][0].hidden=false; }
    if(!R[2][0] && P.pyramid.core?.hidden){ P.pyramid.core.hidden=false; }
  } else if(row===1){
    if(R[1].every(x=>!x) && R[2][0]?.hidden){ R[2][0].hidden=false; }
    if(!R[2][0] && P.pyramid.core?.hidden){ P.pyramid.core.hidden=false; }
  } else if(row===2){
    if(P.pyramid.core?.hidden) P.pyramid.core.hidden=false;
  }
}
function clearCell(P,row,col){
  if(row===3){ P.pyramid.core=null; }
  else { P.pyramid.rows[row][col]=null; }
  flipAfterClear(P,row);
}
function targets(){
  const P=S.players[S.turn];
  return exposedSlots(P).filter(x=>!x.cell.hidden).map(x=>x.cell.card?.r).filter(Boolean);
}
function tryResolve(){
  const t=targets(); if(!t.length) return false;
  // If any card contributed matches a target OR a wild was used, clear one
  const usedWild = S.attempt.some(a=>a.type==="wild");
  const match = usedWild ? t[0] : (S.attempt.find(a=>a.card && t.includes(a.card.r))?.card?.r);
  if(!usedWild && !match) return false;

  const P=S.players[S.turn];
  const ex=exposedSlots(P).filter(x=>!x.cell.hidden);
  let pick = usedWild ? ex[0] : ex.find(x=>x.cell.card?.r===match);
  if(!pick && P.pyramid.core && !P.pyramid.core.hidden) pick={row:3,col:0,cell:P.pyramid.core};
  if(!pick) return false;

  // discard played cards
  for(const a of S.attempt){ if(a.card) S.discard.push(a.card); }
  const cleared = pick.cell.card;
  clearCell(P,pick.row,pick.col);
  if(cleared && isFace(cleared.r)){ P.wilds++; log(`‚≠ê ${P.name} gained a Wild (cleared ${label(cleared)})`); }
  return true;
}
function drawUp(seat){
  const P=S.players[seat];
  while(P.hand.length<4){ const c=safeDraw(); if(!c) return; P.hand.push(c); }
}
function hazard(){
  const P=S.players[S.turn];
  const order=[{r:0,c:0},{r:0,c:1},{r:0,c:2},{r:1,c:0},{r:1,c:1},{r:2,c:0},{r:3,c:0}];
  for(const pos of order){
    const c=safeDraw(); if(!c) return; // game may end in safeDraw
    if(pos.r===3){
      if(!P.pyramid.core){ P.pyramid.core={card:c, hidden:true, haz:true, core:true}; log(`‚ö†Ô∏è Hazard to ${P.name} (core).`); return; }
      S.discard.push(c); continue;
    }
    if(P.pyramid.rows[pos.r][pos.c]===null){
      P.pyramid.rows[pos.r][pos.c]={card:c, hidden:true, haz:true};
      log(`‚ö†Ô∏è Hazard to ${P.name} (row ${pos.r+1}).`);
      return;
    }
    S.discard.push(c);
  }
  end(false,`${P.name}'s pyramid overflowed.`);
}

function end(win,msg){
  if(S.over) return;
  S.over=true; log((win?"üèÜ ":"üí• ")+msg);
}
function checkWin(){
  const P=S.players[S.turn];
  const done = P.pyramid.rows[0].every(x=>!x) && P.pyramid.rows[1].every(x=>!x) && !P.pyramid.rows[2][0] && !P.pyramid.core;
  if(done) end(true,`${P.name} defused their bomb!`);
  return done;
}

/* ===== Game Flow ===== */
function start(){
  S.seatCount=+document.getElementById("playerCount").value;
  S.humanSeat=+document.getElementById("humanSeat").value;
  S.deck=makeDeck(); S.discard=[]; S.reshuffles=1;
  S.players=[]; for(let i=0;i<S.seatCount;i++) S.players.push(newPlayer(i,i===S.humanSeat));
  for(const p of S.players) dealPyramid(p);
  for(let i=0;i<S.seatCount;i++) drawUp(i);
  S.turn=0; S.attempt=[]; S.contributed.clear(); S.started=true; S.over=false;
  render(); maybeBot();
}
function contributionOrder(){ const arr=[S.turn]; if(S.seatCount>1) arr.push((S.turn+1)%S.seatCount); if(S.seatCount>2) arr.push((S.turn+2)%S.seatCount); return arr; }
function currentContributorSeat(){ return contributionOrder()[S.contributed.size] ?? null; }
function canHumanAct(){ return !S.over && S.started && currentContributorSeat()===S.humanSeat; }

function contributePlay(seat, payload){
  S.contributed.add(seat);
  S.attempt.push(payload);
  render();
  if(S.attempt.length===3 || S.contributed.size>=Math.min(3,S.seatCount)){
    // resolve
    const ok = tryResolve();
    if(ok){ for(const s of S.contributed) drawUp(s); S.attempt=[]; S.contributed.clear(); if(checkWin()) return; S.turn=(S.turn+1)%S.seatCount; render(); maybeBot(); }
    else   { log(`‚ùå Attempt failed. Hazard on ${S.players[S.turn].name}.`); hazard(); for(const s of S.contributed) drawUp(s); S.attempt=[]; S.contributed.clear(); if(!S.over){ S.turn=(S.turn+1)%S.seatCount; render(); maybeBot(); } }
  } else {
    maybeBot();
  }
}

/* ===== Human Controls ===== */
let handSel=null;
function onSelectHand(i){ const P=S.players[S.humanSeat]; if(!P) return; handSel=i; render(); }
function playSelected(){ if(!canHumanAct()) return; const P=S.players[S.humanSeat]; if(handSel==null) return; const card=P.hand.splice(handSel,1)[0]; handSel=null; log(`üÉè You play ${label(card)}`); contributePlay(S.humanSeat,{type:"hand", card}); }
function useStaging(){ if(!canHumanAct()) return; const P=S.players[S.humanSeat]; if(!P.stage) return; const card=P.stage; P.stage=null; log(`üóÇÔ∏è You use staging ${label(card)}`); contributePlay(S.humanSeat,{type:"stage", card}); }
function stageSelected(){ if(currentContributorSeat()!==S.humanSeat) return; const P=S.players[S.humanSeat]; if(P.stage){ log("Staging already occupied."); return; } if(handSel==null) return; const card=P.hand.splice(handSel,1)[0]; P.stage=card; handSel=null; log(`üìé You staged ${label(card)}`); // staging counts as your contribution
  contributePlay(S.humanSeat,{type:"stage", card}); }
function useWild(){ if(!canHumanAct()) return; const P=S.players[S.humanSeat]; if((P.wilds||0)<=0) return; P.wilds--; log("‚≠ê You use a Wild"); contributePlay(S.humanSeat,{type:"wild"}); }
function skip(){ if(!canHumanAct()) return; log("‚è≠Ô∏è You skip"); contributePlay(S.humanSeat,{type:"skip"}); }

/* ===== Bot AI (simple, readable) ===== */
function maybeBot(){
  const seat=currentContributorSeat(); if(seat==null || S.over) return;
  const P=S.players[seat]; if(P.isHuman) return;
  setTimeout(()=>{
    const t=targets();
    // 1) hand match
    let idx=P.hand.findIndex(c=>t.includes(c.r));
    if(idx>-1){ const c=P.hand.splice(idx,1)[0]; log(`ü§ñ ${P.name} plays ${label(c)}`); contributePlay(seat,{type:"hand",card:c}); return; }
    // 2) staging match
    if(P.stage && t.includes(P.stage.r)){ const c=P.stage; P.stage=null; log(`ü§ñ ${P.name} uses staging ${label(c)}`); contributePlay(seat,{type:"stage",card:c}); return; }
    // 3) wild
    if(P.wilds>0){ P.wilds--; log(`ü§ñ ${P.name} uses Wild`); contributePlay(seat,{type:"wild"}); return; }
    // 4) stage something (only if active bot to ‚Äòset up‚Äô later)
    if(seat===S.turn && !P.stage && P.hand.length){
      const c=P.hand.pop(); P.stage=c; log(`ü§ñ ${P.name} stages ${label(c)}`); contributePlay(seat,{type:"stage",card:c}); return;
    }
    // 5) skip
    log(`ü§ñ ${P.name} skips`); contributePlay(seat,{type:"skip"});
  }, 250);
}

/* ===== UI ===== */
const $=sel=>document.querySelector(sel);
const playersEl=$("#players"), logEl=$("#log");
function log(t){ const d=document.createElement("div"); d.textContent=t; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; }
function updateBar(){
  $("#turnSpan").textContent = S.started? `Turn: ${S.players[S.turn]?.name}` : "";
  $("#deckSpan").textContent = S.started? `Deck: ${S.deck.length}` : "";
  $("#reshuffleSpan").textContent = S.started? `Reshuffles: ${S.reshuffles}` : "";
  $("#attemptSpan").textContent = S.started? `Attempt: ${S.attempt.length}/3` : "";
  const t=targets(); $("#targets").textContent=t.length? t.join(", "):"‚Äì";
  $("#attemptCount").textContent = `${S.attempt.length}/3`;
}
function cardNode(c,cls=""){ const d=document.createElement("div"); d.className="card "+cls; d.textContent=c.r+GLYPH[c.s]; return d; }
function facedown(){ const d=document.createElement("div"); d.className="card dim"; d.textContent="üÇ†"; return d; }
function emptySlot(){ const d=document.createElement("div"); d.className="slot"; return d; }
function renderCell(cell,allowEmpty,isCore=false){
  if(!cell) return allowEmpty? emptySlot(): document.createElement("div");
  if(cell.hidden) { const x=facedown(); if(cell.haz) x.classList.add("haz"); if(isCore) x.classList.add("core"); return x; }
  const n=cardNode(cell.card, isCore?"core":""); return n;
}
function renderPyramid(P){
  const wrap=document.createElement("div"); wrap.className="pyramid";
  const R=P.pyramid.rows;
  const r2=document.createElement("div"); r2.className="py-row"; r2.appendChild(renderCell(R[2][0],true)); wrap.appendChild(r2);
  const r1=document.createElement("div"); r1.className="py-row"; for(let i=0;i<2;i++) r1.appendChild(renderCell(R[1][i],true)); wrap.appendChild(r1);
  const r0=document.createElement("div"); r0.className="py-row"; for(let i=0;i<3;i++) r0.appendChild(renderCell(R[0][i],true)); wrap.appendChild(r0);
  const core=document.createElement("div"); core.className="py-row"; core.appendChild(renderCell(P.pyramid.core,true,true)); wrap.appendChild(core);
  const expo=exposedSlots(P);
  const rows=wrap.querySelectorAll(".py-row");
  for(const ex of expo){
    if(ex.row===3){ rows[3].firstChild.classList.add("exposed"); }
    else { rows[2-ex.row].children[ex.col]?.classList.add("exposed"); }
  }
  return wrap;
}
function renderPlayer(P){
  const box=document.createElement("div"); box.className="player";
  const h=document.createElement("h2"); h.textContent=`${P.name} ${P.isHuman?"(You)":""}`; box.appendChild(h);
  const tags=document.createElement("div"); tags.className="tags";
  const w=document.createElement("span"); w.className="tag"; w.textContent=`Wilds: ${P.wilds||0}`; tags.appendChild(w);
  const st=document.createElement("span"); st.className="tag"; st.textContent=`Staging: ${P.stage? label(P.stage):"‚Äî"}`; tags.appendChild(st);
  box.appendChild(tags);
  box.appendChild(renderPyramid(P));

  const note=document.createElement("div"); note.style.fontSize="12px"; note.style.color="var(--muted)"; note.textContent=P.isHuman?"Your hand (click to select):":"Bot hand (hidden)"; box.appendChild(note);

  const hand=document.createElement("div"); hand.className="hand";
  if(P.isHuman){
    P.hand.forEach((c,i)=>{
      const n=cardNode(c,"clickable"); if(handSel===i) n.style.outline="2px solid var(--accent)";
      n.addEventListener("click",()=>{ handSel=i; render(); });
      hand.appendChild(n);
    });
  }else{
    P.hand.forEach(()=>hand.appendChild(facedown()));
  }
  box.appendChild(hand);
  return box;
}
function render(){
  if(!S.started) return;
  playersEl.innerHTML="";
  for(const P of S.players) playersEl.appendChild(renderPlayer(P));
  // buttons
  const can = canHumanAct();
  $("#playHand").disabled = !(can && handSel!=null);
  $("#useStage").disabled = !(can && !!S.players[S.humanSeat].stage);
  $("#stageCard").disabled = !(can && handSel!=null && !S.players[S.humanSeat].stage);
  $("#useWild").disabled = !(can && (S.players[S.humanSeat].wilds||0)>0);
  $("#skip").disabled = !can;
  updateBar();
}

/* ===== Wire Up ===== */
document.getElementById("newBtn").onclick = ()=>{ logEl.innerHTML=""; start(); };
document.getElementById("playHand").onclick = playSelected;
document.getElementById("useStage").onclick = useStaging;
document.getElementById("stageCard").onclick = stageSelected;
document.getElementById("useWild").onclick = useWild;
document.getElementById("skip").onclick = skip;

// init hint
log("Tip: Match your exposed ranks. Faces you clear give Wilds. One reshuffle for the entire table.");
</script>
</body>
</html>